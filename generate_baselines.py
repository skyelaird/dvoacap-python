#!/usr/bin/env python3
"""
Generate Regression Baseline Output Files

This script generates VOACAP-formatted output files using DVOACAP-Python's current
implementation. These serve as regression baselines to ensure future changes don't
break existing functionality.

NOTE: These are NOT true VOACAP reference outputs. They are baselines generated by
DVOACAP-Python itself for regression testing. Later, when access to original VOACAP
is available, these baselines can be replaced with true reference outputs.
"""

import sys
import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple
import numpy as np

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.dvoacap.path_geometry import GeoPoint
from src.dvoacap.prediction_engine import PredictionEngine


class VOAInputParser:
    """Parse VOACAP .voa input files"""

    @staticmethod
    def parse_voa_file(filepath: Path) -> Dict:
        """Parse .voa input file and extract parameters"""
        with open(filepath, 'r') as f:
            content = f.read()

        params = {}

        # Parse TIME line: TIME <num_hours> <hour1> <hour2> ...
        time_match = re.search(r'TIME\s+(\d+)\s+([\d\s]+)', content)
        if time_match:
            num_hours = int(time_match.group(1))
            hours_str = time_match.group(2).strip().split()
            params['utc_hours'] = [int(h) for h in hours_str[:num_hours]]

        # Parse MONTH line: MONTH <month1> <month2>
        month_match = re.search(r'MONTH\s+(\d+)\s+(\d+)', content)
        if month_match:
            params['month'] = int(month_match.group(1))

        # Parse SUNSPOT line: SUNSPOT <ssn_min> <ssn_max>
        ssn_match = re.search(r'SUNSPOT\s+(\d+)\s+(\d+)', content)
        if ssn_match:
            params['ssn'] = int(ssn_match.group(1))

        # Parse LABEL line
        label_match = re.search(r'LABEL\s+(.+)', content)
        if label_match:
            params['label'] = label_match.group(1).strip()

        # Parse CIRCUIT line: CIRCUIT <id> <name>
        circuit_match = re.search(r'CIRCUIT\s+\d+\s+(\S+)', content)
        if circuit_match:
            params['circuit_name'] = circuit_match.group(1)

        # Parse TRANSMIT line: TRANSMIT <lat> <lon>
        tx_match = re.search(r'TRANSMIT\s+([-\d.]+)\s+([-\d.]+)', content)
        if tx_match:
            params['tx_lat'] = float(tx_match.group(1))
            params['tx_lon'] = float(tx_match.group(2))

        # Parse RECEIVE line: RECEIVE <lat> <lon>
        rx_match = re.search(r'RECEIVE\s+([-\d.]+)\s+([-\d.]+)', content)
        if rx_match:
            params['rx_lat'] = float(rx_match.group(1))
            params['rx_lon'] = float(rx_match.group(2))

        # Parse SYSTEM line: SYSTEM <power> <snr> <rel>
        system_match = re.search(r'SYSTEM\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)', content)
        if system_match:
            params['tx_power_w'] = float(system_match.group(1)) * 1000  # kW to W
            params['req_snr'] = float(system_match.group(2))
            params['req_rel'] = float(system_match.group(3))

        # Parse FREQUENCY line: FREQUENCY <num> <freq1> <freq2> ...
        freq_match = re.search(r'FREQUENCY\s+(\d+)\s+([\d.\s]+)', content)
        if freq_match:
            num_freqs = int(freq_match.group(1))
            freqs_str = freq_match.group(2).strip().split()
            params['frequencies'] = [float(f) for f in freqs_str[:num_freqs]]

        return params


class VOAOutputGenerator:
    """Generate VOACAP-formatted output from DVOACAP-Python predictions"""

    def __init__(self, params: Dict):
        self.params = params
        self.engine = PredictionEngine()
        self.predictions_by_hour = {}

    def run_predictions(self):
        """Run predictions for all hours and frequencies"""
        print(f"Running predictions for {self.params.get('label', 'Unknown')}...")
        print(f"  SSN: {self.params['ssn']}, Month: {self.params['month']}")
        print(f"  TX: {self.params['tx_lat']:.2f}, {self.params['tx_lon']:.2f}")
        print(f"  RX: {self.params['rx_lat']:.2f}, {self.params['rx_lon']:.2f}")
        print(f"  Frequencies: {len(self.params['frequencies'])}")
        print(f"  Hours: {len(self.params['utc_hours'])}")

        # Configure engine
        self.engine.params.ssn = float(self.params['ssn'])
        self.engine.params.month = self.params['month']
        self.engine.params.tx_power = self.params['tx_power_w']
        self.engine.params.tx_location = GeoPoint.from_degrees(
            self.params['tx_lat'], self.params['tx_lon']
        )
        self.engine.params.min_angle = np.deg2rad(0.1)  # Match VOACAP default

        rx_location = GeoPoint.from_degrees(
            self.params['rx_lat'], self.params['rx_lon']
        )

        # Run predictions for each hour
        for hour in self.params['utc_hours']:
            utc_fraction = hour / 24.0

            try:
                self.engine.predict(
                    rx_location=rx_location,
                    utc_time=utc_fraction,
                    frequencies=self.params['frequencies']
                )

                # Store predictions
                muf = self.engine.circuit_muf.muf if self.engine.circuit_muf else 0.0
                self.predictions_by_hour[hour] = {
                    'muf': muf,
                    'predictions': list(self.engine.predictions)  # Copy list
                }

                print(f"  Hour {hour:02d}: MUF = {muf:.1f} MHz, {len(self.engine.predictions)} modes")

            except Exception as e:
                print(f"  Hour {hour:02d}: ERROR - {e}")
                self.predictions_by_hour[hour] = {
                    'muf': 0.0,
                    'predictions': []
                }

    def format_value(self, value, mode_value=False):
        """Format a value for VOACAP output"""
        if value is None or (isinstance(value, float) and (np.isnan(value) or np.isinf(value))):
            return "   -"

        if mode_value:
            # Mode values like "1F2", "2E", etc.
            return f"{value:>4s}"

        if isinstance(value, float):
            if abs(value) >= 100:
                return f"{value:>4.0f}"
            elif abs(value) >= 10:
                return f"{value:>4.1f}"
            else:
                return f"{value:>4.2f}"

        return f"{value:>4}"

    def generate_output(self) -> str:
        """Generate VOACAP-formatted output"""
        lines = []

        # Header
        lines.append("  IONOSPHERIC COMMUNICATIONS ANALYSIS AND PREDICTION PROGRAM")
        lines.append("                     DVOACAP-PYTHON BASELINE")
        lines.append(" ")
        lines.append(" ")
        lines.append("          1         2         3         4         5         6         7")
        lines.append(" 123456789012345678901234567890123456789012345678901234567890123456789012345")
        lines.append(" ")
        lines.append(f" BASELINE GENERATED: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append(" NOTE: This is a DVOACAP-Python regression baseline, NOT true VOACAP reference")
        lines.append(" ")
        lines.append(f" LABEL     {self.params.get('label', 'Test Path')}")

        # Circuit line
        tx_lat = self.params['tx_lat']
        tx_lon = self.params['tx_lon']
        rx_lat = self.params['rx_lat']
        rx_lon = self.params['rx_lon']

        tx_lat_str = f"{abs(tx_lat):5.2f}{'N' if tx_lat >= 0 else 'S'}"
        tx_lon_str = f"{abs(tx_lon):6.2f}{'E' if tx_lon >= 0 else 'W'}"
        rx_lat_str = f"{abs(rx_lat):5.2f}{'N' if rx_lat >= 0 else 'S'}"
        rx_lon_str = f"{abs(rx_lon):6.2f}{'E' if rx_lon >= 0 else 'W'}"

        lines.append(f" CIRCUIT   {tx_lat_str:>8} {tx_lon_str:>9} - {rx_lat_str:>8} {rx_lon_str:>9}  S     0")
        lines.append(f" MONTH      1994 {self.params['month']}.00")
        lines.append(f" SUNSPOT    {self.params['ssn']:.0f}.")
        lines.append(" ")

        # For each hour, output prediction block
        for hour in sorted(self.predictions_by_hour.keys()):
            hour_data = self.predictions_by_hour[hour]
            muf = hour_data['muf']
            predictions = hour_data['predictions']

            # Build frequency line
            freq_str = f"{hour:>4.1f} {muf:>4.1f}"
            for freq in self.params['frequencies']:
                freq_str += f" {freq:>4.1f}" if freq < 100 else f"{freq:>5.1f}"
            freq_str += "  FREQ"
            lines.append(" ")
            lines.append(freq_str)

            # Build metric lines
            metrics = {
                'MODE': [],
                'TANGLE': [],
                'DELAY': [],
                'V HITE': [],
                'MUFday': [],
                'LOSS': [],
                'DBU': [],
                'S DBW': [],
                'N DBW': [],
                'SNR': [],
                'RPWRG': [],
                'REL': [],
                'MPROB': [],
                'S PRB': [],
                'SIG LW': [],
                'SIG UP': [],
                'SNR LW': [],
                'SNR UP': [],
                'TGAIN': [],
                'RGAIN': [],
                'SNRxx': []
            }

            # Extract values from predictions
            for i, freq in enumerate(self.params['frequencies']):
                if i < len(predictions):
                    pred = predictions[i]
                    metrics['MODE'].append(pred.get_mode_name(self.engine.path.dist))
                    metrics['TANGLE'].append(np.rad2deg(pred.tx_elevation) if pred.tx_elevation else None)
                    metrics['DELAY'].append(None)  # Not implemented
                    metrics['V HITE'].append(pred.virt_height if hasattr(pred, 'virt_height') else None)
                    metrics['MUFday'].append(pred.signal.muf_day if hasattr(pred.signal, 'muf_day') else None)
                    metrics['LOSS'].append(pred.signal.total_loss_db if hasattr(pred.signal, 'total_loss_db') else None)
                    metrics['DBU'].append(None)  # Not directly available
                    metrics['S DBW'].append(pred.signal.power_dbw if hasattr(pred.signal, 'power_dbw') else None)
                    metrics['N DBW'].append(pred.signal.noise_dbw if hasattr(pred.signal, 'noise_dbw') else None)
                    metrics['SNR'].append(pred.signal.snr_db if hasattr(pred.signal, 'snr_db') else None)
                    metrics['RPWRG'].append(None)  # Not implemented
                    metrics['REL'].append(pred.signal.reliability if hasattr(pred.signal, 'reliability') else None)
                    metrics['MPROB'].append(None)  # Not implemented
                    metrics['S PRB'].append(None)  # Not implemented
                    metrics['SIG LW'].append(None)  # Not implemented
                    metrics['SIG UP'].append(None)  # Not implemented
                    metrics['SNR LW'].append(None)  # Not implemented
                    metrics['SNR UP'].append(None)  # Not implemented
                    metrics['TGAIN'].append(0.0)  # Isotropic
                    metrics['RGAIN'].append(0.0)  # Isotropic
                    metrics['SNRxx'].append(pred.signal.snr_db if hasattr(pred.signal, 'snr_db') else None)
                else:
                    # No valid mode for this frequency
                    for key in metrics:
                        metrics[key].append(None)

            # Format and output metric lines
            for metric_name in ['MODE', 'TANGLE', 'DELAY', 'V HITE', 'MUFday', 'LOSS',
                               'DBU', 'S DBW', 'N DBW', 'SNR', 'RPWRG', 'REL', 'MPROB',
                               'S PRB', 'SIG LW', 'SIG UP', 'SNR LW', 'SNR UP',
                               'TGAIN', 'RGAIN', 'SNRxx']:
                line = "      "  # Indent

                # Add MUF column value (typically different from freq values)
                if metric_name == 'MODE':
                    line += "  - "
                elif metric_name in ['TGAIN', 'RGAIN']:
                    line += " 0.0"
                else:
                    line += "  - "

                # Add frequency column values
                for value in metrics[metric_name]:
                    if metric_name == 'MODE':
                        mode_str = str(value) if value else "-"
                        line += f" {mode_str:>3s}"
                    else:
                        line += f" {self.format_value(value)}"

                line += f"  {metric_name}"
                lines.append(line)

        return '\n'.join(lines) + '\n'

    def save_output(self, output_file: Path):
        """Save generated output to file"""
        output = self.generate_output()

        with open(output_file, 'w') as f:
            f.write(output)

        print(f"\nBaseline saved to: {output_file}")


def generate_baseline_for_test_case(voa_file: Path, output_file: Path):
    """Generate baseline output for a test case"""
    print(f"\n{'='*80}")
    print(f"Generating baseline: {voa_file.name} -> {output_file.name}")
    print(f"{'='*80}")

    # Parse input file
    parser = VOAInputParser()
    params = parser.parse_voa_file(voa_file)

    # Generate predictions
    generator = VOAOutputGenerator(params)
    generator.run_predictions()

    # Save output
    generator.save_output(output_file)


def main():
    """Generate all baseline outputs"""
    sample_dir = Path(__file__).parent / 'SampleIO'

    test_cases = [
        ('input_short_001_us_east.voa', 'ref_short_001.out'),
        ('input_short_002_europe.voa', 'ref_short_002.out'),
        ('input_medium_001_transatlantic.voa', 'ref_medium_001.out'),
        ('input_medium_002_us_japan.voa', 'ref_medium_002.out'),
        ('input_long_001_antipodal.voa', 'ref_long_001.out'),
        ('input_long_002_australia.voa', 'ref_long_002.out'),
        ('input_polar_001_arctic.voa', 'ref_polar_001.out'),
        ('input_equatorial_001.voa', 'ref_equatorial_001.out'),
        ('input_solar_min_001.voa', 'ref_solar_min_001.out'),
        ('input_solar_max_001.voa', 'ref_solar_max_001.out'),
    ]

    print("=" * 80)
    print("DVOACAP-Python Baseline Generator")
    print("=" * 80)
    print()
    print("This script generates regression baseline outputs for test cases.")
    print("These are NOT true VOACAP references - they are DVOACAP-Python baselines")
    print("for regression testing to ensure future changes don't break functionality.")
    print()

    for voa_filename, out_filename in test_cases:
        voa_file = sample_dir / voa_filename
        output_file = sample_dir / out_filename

        if not voa_file.exists():
            print(f"⚠️  Input file not found: {voa_file}")
            continue

        try:
            generate_baseline_for_test_case(voa_file, output_file)
        except Exception as e:
            print(f"❌ Error generating baseline: {e}")
            import traceback
            traceback.print_exc()

    print()
    print("=" * 80)
    print("Baseline generation complete!")
    print("=" * 80)
    print()
    print("Next steps:")
    print("1. Review generated .out files in SampleIO/")
    print("2. Update test_config.json to activate test cases")
    print("3. Run: python test_voacap_reference.py")


if __name__ == '__main__':
    main()
