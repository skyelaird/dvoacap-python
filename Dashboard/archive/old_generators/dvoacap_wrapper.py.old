#!/usr/bin/env python3
"""
DVOACAP Python Wrapper
Calls the dvoa.dll for accurate VOACAP predictions
"""

import json
import ctypes
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

class DVOACAPEngine:
    """Python wrapper for DVOACAP DLL"""
    
    def __init__(self, dll_path: str = "./dvoa.dll"):
        """Initialize the DVOACAP engine
        
        Args:
            dll_path: Path to dvoa.dll file
        """
        dll_file = Path(dll_path)
        if not dll_file.exists():
            raise FileNotFoundError(f"DVOACAP DLL not found at: {dll_path}")
        
        # Load the DLL
        self.dll = ctypes.WinDLL(str(dll_file))
        
        # Define the Predict function signature
        # extern "C" {char* __declspec(dllexport) __stdcall Predict(char* ArgsStr);}
        self.dll.Predict.argtypes = [ctypes.c_char_p]
        self.dll.Predict.restype = ctypes.c_char_p
        
        print(f"✓ DVOACAP engine loaded from {dll_path}")
    
    def predict(self, 
                tx_lat: float, tx_lon: float,
                rx_lat: float, rx_lon: float,
                frequency_mhz: float,
                hour_utc: int,
                ssn: int,
                power_watts: int = 1500,
                month: int = None,
                **kwargs) -> Dict:
        """Run VOACAP prediction
        
        Args:
            tx_lat: Transmitter latitude
            tx_lon: Transmitter longitude
            rx_lat: Receiver latitude
            rx_lon: Receiver longitude
            frequency_mhz: Frequency in MHz
            hour_utc: UTC hour (0-23)
            ssn: Smoothed sunspot number
            power_watts: Transmit power
            month: Month (1-12), defaults to current month
            
        Returns:
            Dictionary with prediction results
        """
        if month is None:
            month = datetime.now().month
        
        # Build DVOACAP JSON input
        # Format based on DVOACAP documentation
        input_data = {
            "Method": 30,  # Area method
            "Transmitter": {
                "Latitude": tx_lat,
                "Longitude": tx_lon,
                "Power": power_watts
            },
            "Receiver": {
                "Latitude": rx_lat,
                "Longitude": rx_lon
            },
            "Path": {
                "Bearing": None  # Auto-calculate
            },
            "Frequencies": [frequency_mhz],
            "Hours": [hour_utc],
            "Month": month,
            "SSN": ssn,
            "Coeffs": {
                "CCIR": True  # Use CCIR coefficients
            },
            "OutputFormat": "json"
        }
        
        # Convert to JSON string
        input_json = json.dumps(input_data)
        
        # Call the DLL
        try:
            result_bytes = self.dll.Predict(input_json.encode('utf-8'))
            result_json = result_bytes.decode('utf-8')
            
            # Parse the result
            result = json.loads(result_json)
            return result
            
        except Exception as e:
            print(f"✗ DVOACAP prediction error: {e}")
            return None
    
    def predict_simple(self,
                      tx_lat: float, tx_lon: float,
                      rx_lat: float, rx_lon: float,
                      frequency_mhz: float,
                      hour_utc: int,
                      ssn: int) -> Dict:
        """Simplified prediction returning just the essentials
        
        Returns:
            {
                'reliability': int (0-100),
                'snr_db': float,
                'quality': str (GOOD/FAIR/POOR),
                'muf': float,
                'method': 'VOACAP'
            }
        """
        result = self.predict(tx_lat, tx_lon, rx_lat, rx_lon,
                            frequency_mhz, hour_utc, ssn)
        
        if not result:
            return {
                'reliability': 0,
                'snr_db': -99,
                'quality': 'POOR',
                'muf': 0,
                'method': 'VOACAP-ERROR'
            }
        
        # Extract key metrics from DVOACAP result
        # (Format depends on actual DVOACAP output - need to adjust after testing)
        try:
            reliability = result.get('Reliability', 0)
            snr = result.get('SNR', -99)
            muf = result.get('MUF', 0)
            
            # Determine quality
            if reliability >= 70:
                quality = 'GOOD'
            elif reliability >= 40:
                quality = 'FAIR'
            else:
                quality = 'POOR'
            
            return {
                'reliability': reliability,
                'snr_db': snr,
                'quality': quality,
                'muf': muf,
                'method': 'VOACAP'
            }
        except Exception as e:
            print(f"✗ Error parsing DVOACAP result: {e}")
            return {
                'reliability': 0,
                'snr_db': -99,
                'quality': 'ERROR',
                'muf': 0,
                'method': 'VOACAP-PARSE-ERROR'
            }


def test_dvoacap():
    """Test the DVOACAP wrapper"""
    print("Testing DVOACAP Engine...")
    print("=" * 60)
    
    try:
        # Initialize engine
        engine = DVOACAPEngine("dvoa.dll")
        
        # Test prediction: Halifax to London
        print("\nTest prediction: VE1ATM -> UK (London)")
        print("  Path: ~4500 km across Atlantic")
        print("  Band: 20m (14.15 MHz)")
        print("  SSN: 140 (typical)")
        
        result = engine.predict_simple(
            tx_lat=44.374, tx_lon=-64.300,  # Halifax
            rx_lat=51.5, rx_lon=-0.1,       # London
            frequency_mhz=14.15,
            hour_utc=18,  # 18:00 UTC
            ssn=140
        )
        
        print(f"\nResult:")
        print(f"  Method: {result['method']}")
        print(f"  Quality: {result['quality']}")
        print(f"  Reliability: {result['reliability']}%")
        print(f"  SNR: {result['snr_db']} dB")
        print(f"  MUF: {result['muf']} MHz")
        
        if result['quality'] == 'GOOD':
            print("\n✓ DVOACAP prediction successful!")
        
    except FileNotFoundError as e:
        print(f"\n✗ {e}")
        print("\n  To fix:")
        print("    1. Download DVOACAP from: https://github.com/VE3NEA/DVOACAP")
        print("    2. Extract dvoa.dll to the same folder as this script")
        print("    3. Run this test again")
    except Exception as e:
        print(f"\n✗ Error: {e}")
        import traceback
        traceback.print_exc()
    
    print("\n" + "=" * 60)


if __name__ == '__main__':
    test_dvoacap()
